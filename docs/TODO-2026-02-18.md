# TODOs fÃ¼r 18.02.2026

Vorbereitet von Claudius ðŸ¦‘ fÃ¼r Steffen & Christopher.

---

## 1. ðŸ“Š Token-Tracking pro Benutzer

**Ziel:** Ãœbersicht welcher Nutzer welches Modell wie oft/viel nutzt. Sichtbar im Profil (Steffen, Christopher, Micha).

### Datenmodell
```sql
CREATE TABLE token_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    teacher_id UUID REFERENCES teachers(id),
    model TEXT NOT NULL,           -- z.B. 'claude-sonnet-4', 'claude-3-5-haiku'
    input_tokens INTEGER DEFAULT 0,
    output_tokens INTEGER DEFAULT 0,
    agent_type TEXT,               -- 'main', 'klausur', 'memory', etc.
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_token_usage_teacher ON token_usage(teacher_id);
CREATE INDEX idx_token_usage_date ON token_usage(created_at);
```

### Backend
- **Logging-Hook in Pydantic AI**: Nach jedem `agent.run()` â†’ `usage()` auslesen â†’ in `token_usage` schreiben
- Pydantic AI gibt `result.usage()` zurÃ¼ck mit `input_tokens`, `output_tokens`
- Fire-and-forget Insert (wie Memory-Agent)
- Erfasst ALLE Agent-Calls: Main, Sub-Agents (Klausur, Memory, Curriculum, etc.)

### API Endpoints
```
GET /api/profile/token-usage?days=7     â†’ Tageweise Aggregation
GET /api/profile/token-usage?days=30    â†’ MonatsÃ¼bersicht
```

Response:
```json
{
  "daily": [
    { "date": "2026-02-18", "model": "claude-sonnet-4", "input_tokens": 12400, "output_tokens": 8200, "calls": 15 },
    { "date": "2026-02-18", "model": "claude-3-5-haiku", "input_tokens": 3200, "output_tokens": 1800, "calls": 8 }
  ],
  "total": { "input_tokens": 15600, "output_tokens": 10000, "calls": 23 }
}
```

### Frontend (ProfilePage)
- Neue Section "Token-Verbrauch" im Profil
- Tabelle: Datum | Modell | Input | Output | Calls
- Optional: Kleines Balkendiagramm pro Tag (CSS-only, kein Chart-Lib)

### Aufwand: ~2-3h
- DB: 10 min (SQL + RLS)
- Backend Hook: 30 min (zentrale Stelle in agent runner)
- API: 20 min
- Frontend: 1h

---

## 2. ðŸ”˜ RÃ¼ckfrage-Cards mit Klick-Buttons

**Ziel:** Wenn der Agent Optionen zur Auswahl gibt, sollen das klickbare Buttons sein statt Text.

### Ist-Zustand
- `ClarificationCard.tsx` existiert bereits âœ…
- `ask_teacher` Tool mit `options`-Feld existiert âœ…
- Backend schickt `clarification.options` als Array von Strings
- Frontend zeigt die Optionen bereits als Buttons an

### Problem
- Aktuell nutzen nur wenige Agents die `ask_teacher`-Funktion mit `options`
- Manche Agents formulieren RÃ¼ckfragen als FlieÃŸtext statt strukturiert
- Nach Klick wird die Option als Text-Nachricht gesendet â†’ funktioniert

### Was fehlt
1. **Mehr Agents mÃ¼ssen `options` nutzen**: Alle 12 Material-Agents prÃ¼fen ob sie bei RÃ¼ckfragen `options` setzen
2. **Styling verbessern**: Buttons prominenter, ggf. Icons
3. **Multi-Step Wizard**: Wenn Agent mehrere RÃ¼ckfragen nacheinander stellt â†’ jede als eigene Card
4. **Referenz: Claude.ai**: Nutzt "suggested replies" als Chips unter der Nachricht

### Vergleich mit Claude.ai
Claude.ai zeigt "suggested replies" als kleine Chips/Buttons am unteren Rand der Antwort. Die werden per API als `stop_reason: "tool_use"` + structured output zurÃ¼ckgegeben. Unser System macht das Ã¤hnlich via `ClarificationNeededError` + `options`.

### Aufwand: ~1-2h
- Agents durchgehen: 30 min (Prompts anpassen)
- Frontend Polish: 30 min
- Testing: 30 min

---

## 3. â³ Agent-Arbeitsanzeige (Pulsing Indicator)

**Ziel:** Wenn ein Material-Agent generiert, soll der User sehen DASS etwas passiert (nicht einfach stiller Textstream).

### Ist-Zustand
- SSE Streaming existiert âœ…
- Bei Chat-Antworten: Text streamt Wort fÃ¼r Wort
- Bei Material-Generierung: Agent denkt lange, dann kommt alles auf einmal
- Tool-Call-Schritte werden als `[ðŸ”§ Tool wird ausgefÃ¼hrt...]` angezeigt

### GewÃ¼nschtes Verhalten
1. **Schritt-Anzeige**: "ðŸ” Analysiere Anforderungen..." â†’ "ðŸ“ Erstelle Aufgaben..." â†’ "âœ… Fertig!"
2. **Pulsing-Animation**: Sichtbarer Indikator dass der Agent arbeitet
3. **Ergebnis in eigener Nachricht**: Erst kurze Zusammenfassung, dann Material als separater Block

### Technische Umsetzung
- SSE Events erweitern: `event: step` mit `{ "step": "Erstelle Klausur...", "progress": 0.3 }`
- Frontend: `StepIndicator.tsx` Komponente mit Pulse-Animation
- Main Agent sendet Zwischen-Updates via SSE bevor Sub-Agent-Ergebnis kommt
- Material-Ergebnis als eigene "Nachricht" im Chat (nicht inline im Stream)

### Aufwand: ~2-3h
- Backend SSE Steps: 1h
- Frontend StepIndicator: 1h
- Integration + Test: 1h

---

## 4. ðŸ§  Memory-System Review & Restructuring

**Ziel:** Memory-System analysieren, aufrÃ¤umen, fÃ¼r User sichtbar machen, Kurz-/LangzeitgedÃ¤chtnis trennen.

### Ist-Zustand
- **Tabelle**: `user_memories` (Supabase)
- **Felder**: `id, teacher_id, category, key, value, created_at, updated_at, access_count`
- **Aktuell ~231 EintrÃ¤ge** (nach Dedup von 266) fÃ¼r Steffen
- **Top 50** werden per Recency+Relevancy in System-Prompt geladen (~854 Tokens)
- **Memory-Agent** (Haiku): LÃ¤uft fire-and-forget nach jeder Nachricht, extrahiert neue Memories
- **Problem**: Massive Duplikation (gleicher Wert unter verschiedenen category/key)
- **Categories**: teaching_preferences, personal_info, subject_knowledge, etc.

### Analyse-Fragen
```sql
-- Wie viele Memories pro Teacher?
SELECT teacher_id, COUNT(*) FROM user_memories GROUP BY teacher_id;

-- Kategorien-Verteilung
SELECT category, COUNT(*) FROM user_memories 
WHERE teacher_id = 'STEFFEN_ID' GROUP BY category ORDER BY count DESC;

-- Duplikate finden
SELECT value, COUNT(*) as cnt FROM user_memories 
WHERE teacher_id = 'STEFFEN_ID' GROUP BY value HAVING COUNT(*) > 1;

-- Durchschnittliches Alter
SELECT AVG(EXTRACT(EPOCH FROM (now() - created_at))/86400) as avg_days 
FROM user_memories WHERE teacher_id = 'STEFFEN_ID';
```

### Christophers Vorschlag: Kurz- vs. LangzeitgedÃ¤chtnis

| Aspekt | KurzzeitgedÃ¤chtnis (STM) | LangzeitgedÃ¤chtnis (LTM) |
|--------|--------------------------|--------------------------|
| Quelle | Letzte ~30 Nachrichten | user_memories Tabelle |
| Inhalt | Aktueller Kontext, laufende Aufgaben | Preferences, Fakten, Gewohnheiten |
| Lebensdauer | Session-basiert | Permanent (mit Decay) |
| Im Prompt | Immer (als Chat-History) | Top-N nach Relevanz+Recency |
| Verwaltung | Automatisch (Conversation) | Memory-Agent + Cleanup-Cron |

### Steffens Idee: Kategorien-Sortierung
Memories nach Kategorien gruppiert anzeigen:
- ðŸ‘¤ **PersÃ¶nliches**: Name, Schule, Erfahrung
- ðŸ“š **FÃ¤cher & Klassen**: Welche FÃ¤cher, welche Stufen
- ðŸŽ¯ **PrÃ¤ferenzen**: Bevorzugte Methoden, Stile
- ðŸ“‹ **Laufende Aufgaben**: Aktuelle Projekte, offene Todos
- ðŸ’¡ **Gelerntes**: Was der Agent Ã¼ber den Nutzer gelernt hat

### User-Facing Memory View
```
GET /api/profile/memories              â†’ Alle Memories, kategorisiert
DELETE /api/profile/memories/:id       â†’ Einzelne Memory lÃ¶schen
PUT /api/profile/memories/:id          â†’ Memory bearbeiten
```

Frontend: Neue Seite oder Section im Profil
- Grouped by Category
- Jede Memory editierbar/lÃ¶schbar
- "Was weiÃŸ die KI Ã¼ber mich?" Transparenz

### Cleanup-Cron
- **Option A**: Cron-Job (z.B. 3x/Tag) der Duplikate merged, alte/irrelevante lÃ¶scht
- **Option B**: Memory-Agent bekommt `cleanup` Tool das bei jedem Write auch prÃ¼ft
- **Option C**: Batch-Cleanup als Admin-Endpoint (manuell oder per Cron triggerbar)

**Empfehlung**: Option A + C. Cron fÃ¼r regelmÃ¤ÃŸige Pflege, Admin-Endpoint fÃ¼r manuelle Eingriffe.

### Aufwand: ~3-4h
- Analyse (SQL Queries): 30 min
- API Endpoints: 1h
- Frontend Memory-View: 1.5h
- Cleanup-Logik: 1h

---

## Zusammenfassung

| # | Feature | Aufwand | PrioritÃ¤t |
|---|---------|---------|-----------|
| 1 | Token-Tracking | 2-3h | Hoch (Transparenz) |
| 2 | RÃ¼ckfrage-Buttons | 1-2h | Mittel (UX) |
| 3 | Agent-Arbeitsanzeige | 2-3h | Mittel (UX) |
| 4 | Memory-Restructuring | 3-4h | Hoch (Architektur) |

**Gesamt: ~8-12h Arbeit**

### Benchmark-Ergebnis (Referenz)
Medium Suite: **28/30 (93%)** âœ…
- J01 Klausur: 5/5 âœ…
- J02 Differenzierung: 2/3 (Assertion zu eng)
- J03 H5P: 2/4 (Assertion zu eng)  
- J04 Lehrplan: 3/3 âœ…
- J05 Stundenplanung: 3/3 âœ…
- J06 Memory: 3/3 âœ…
- J11 Multi-Turn: 4/4 âœ…
- J13 Todos: 2/2 âœ…
- QualitÃ¤t: 3/3 âœ…
